From 7249492bac6ed3a47a48b2c0916de4e3d834974d Mon Sep 17 00:00:00 2001
From: Thomas Nizan <tnizan@witekio.com>
Date: Fri, 21 May 2021 13:10:43 -0700
Subject: [PATCH 12/15] media: i2c: max9286: WIP for mars compatibility

---
 drivers/media/i2c/max9286.c | 160 +++++++++++++++++++++++++++++-------
 1 file changed, 131 insertions(+), 29 deletions(-)

diff --git a/drivers/media/i2c/max9286.c b/drivers/media/i2c/max9286.c
index e96053b67eb6..33b10684a25b 100644
--- a/drivers/media/i2c/max9286.c
+++ b/drivers/media/i2c/max9286.c
@@ -10,6 +10,8 @@
  * Copyright (C) 2015 Cogent Embedded, Inc.
  */
 
+#define DEBUG
+
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/fwnode.h>
@@ -83,7 +85,7 @@
 #define MAX9286_VC(n)			((n) << 5)
 #define MAX9286_VCTYPE			BIT(4)
 #define MAX9286_CSIOUTEN		BIT(3)
-#define MAX9286_0X15_RESV		(3 << 0)
+#define MAX9286_0X15_RESV		(7 << 0) // was getting image noise with RESV=3
 /* Register 0x1b */
 #define MAX9286_SWITCHIN(n)		(1 << ((n) + 4))
 #define MAX9286_ENEQ(n)			(1 << (n))
@@ -137,6 +139,9 @@
 struct max9286_source {
 	struct v4l2_subdev *sd;
 	struct fwnode_handle *fwnode;
+	struct device *dev;
+	struct regulator *regulator;
+
 };
 
 struct max9286_asd {
@@ -229,6 +234,8 @@ static int max9286_write(struct max9286_priv *priv, u8 reg, u8 val)
 {
 	int ret;
 
+	dev_dbg(&priv->client->dev, "%s(0x%02x, 0x%02x)\n", __func__, reg, val);
+
 	ret = i2c_smbus_write_byte_data(priv->client, reg, val);
 	if (ret < 0)
 		dev_err(&priv->client->dev,
@@ -329,7 +336,7 @@ static int max9286_i2c_mux_init(struct max9286_priv *priv)
 static void max9286_configure_i2c(struct max9286_priv *priv, bool localack)
 {
 	u8 config = MAX9286_I2CSLVSH_469NS_234NS | MAX9286_I2CSLVTO_1024US |
-		    MAX9286_I2CMSTBT_105KBPS;
+		    MAX9286_I2CMSTBT_339KBPS;
 
 	if (localack)
 		config |= MAX9286_I2CLOCACK;
@@ -816,9 +823,9 @@ static const struct v4l2_subdev_ops max9286_subdev_ops = {
 
 static void max9286_init_format(struct v4l2_mbus_framefmt *fmt)
 {
-	fmt->width		= 1280;
-	fmt->height		= 800;
-	fmt->code		= MEDIA_BUS_FMT_UYVY8_1X16;
+	fmt->width		= 1920;
+	fmt->height		= 1080;
+	fmt->code		= MEDIA_BUS_FMT_SGRBG8_1X8;
 	fmt->colorspace		= V4L2_COLORSPACE_SRGB;
 	fmt->field		= V4L2_FIELD_NONE;
 	fmt->ycbcr_enc		= V4L2_YCBCR_ENC_DEFAULT;
@@ -908,7 +915,7 @@ static int max9286_v4l2_register(struct max9286_priv *priv)
 		ret = -ENOENT;
 		goto err_async;
 	}
-	priv->sd.fwnode = ep;
+	//priv->sd.fwnode = ep;
 
 	ret = v4l2_async_register_subdev(&priv->sd);
 	if (ret < 0) {
@@ -988,18 +995,22 @@ static int max9286_setup(struct max9286_priv *priv)
 	 */
 	max9286_write(priv, 0x15, MAX9286_VCTYPE | MAX9286_0X15_RESV);
 
-	/* Enable CSI-2 Lane D0-D3 only, DBL mode, YUV422 8-bit. */
+	/* Enable CSI-2 Lane D0-D3 only, DBL mode, RAW11. */
 	max9286_write(priv, 0x12, MAX9286_CSIDBL | MAX9286_DBL |
 		      MAX9286_CSILANECNT(priv->csi2_data_lanes) |
-		      MAX9286_DATATYPE_YUV422_8BIT);
+		      MAX9286_DATATYPE_RAW11);
 
-	/* Automatic: FRAMESYNC taken from the slowest Link. */
-	max9286_write(priv, 0x01, MAX9286_FSYNCMODE_INT_HIZ |
-		      MAX9286_FSYNCMETH_AUTO);
+	/* Manual FRAMESYNC*/
+	max9286_write(priv, 0x01, MAX9286_FSYNCMODE_INT_OUT |
+		      MAX9286_FSYNCMETH_MANUAL);
 
-	/* Enable HS/VS encoding, use D14/15 for HS/VS, invert VS. */
-	max9286_write(priv, 0x0c, MAX9286_HVEN | MAX9286_INVVS |
-		      MAX9286_HVSRC_D14);
+	max9286_write(priv, 0x06, 0xA0);	// [7:0] FSYNC_PERIODL
+	max9286_write(priv, 0x07, 0x25);	// [7:0] FSYNC_PERIODM
+	max9286_write(priv, 0x08, 0x26);	// [7:0] FSYNC_PERIODH
+
+	/* Enable HS/VS encoding, use HS as line valid source, use D14/15 for HS/VS, invert VS. */
+	max9286_write(priv, 0x0c, MAX9286_HVEN | MAX9286_DESEL |
+		      MAX9286_INVVS | MAX9286_HVSRC_D14);
 
 	/*
 	 * The overlap window seems to provide additional validation by tracking
@@ -1012,6 +1023,7 @@ static int max9286_setup(struct max9286_priv *priv)
 	 */
 	max9286_write(priv, 0x63, 0);
 	max9286_write(priv, 0x64, 0);
+	max9286_write(priv, 0x1C, 0x06); //Reserved bytes [3:0] must be = 0x06
 
 	/*
 	 * Wait for 2ms to allow the link to resynchronize after the
@@ -1073,16 +1085,28 @@ static int max9286_init(struct device *dev)
 {
 	struct max9286_priv *priv;
 	struct i2c_client *client;
+	struct max9286_source *source;
 	int ret;
 
 	client = to_i2c_client(dev);
 	priv = i2c_get_clientdata(client);
 
 	/* Enable the bus power. */
-	ret = regulator_enable(priv->regulator);
-	if (ret < 0) {
-		dev_err(&client->dev, "Unable to turn PoC on\n");
-		return ret;
+	if (priv->regulator)
+	{
+		ret = regulator_enable(priv->regulator);
+		if (ret < 0) {
+			dev_err(dev, "Unable to turn PoC on\n");
+			return ret;
+		}
+	} else {
+		for_each_source(priv, source) {
+			ret = regulator_enable(source->regulator);
+			if (ret < 0) {
+				dev_err(dev, "Unable to turn PoC on\n");
+				return ret;
+			}
+		}
 	}
 
 	ret = max9286_setup(priv);
@@ -1115,7 +1139,14 @@ static int max9286_init(struct device *dev)
 err_v4l2_register:
 	max9286_v4l2_unregister(priv);
 err_regulator:
-	regulator_disable(priv->regulator);
+	if (priv->regulator)
+	{
+		regulator_disable(priv->regulator);
+	} else {
+		for_each_source(priv, source) {
+			regulator_disable(source->regulator);
+		}
+	}
 
 	return ret;
 }
@@ -1127,9 +1158,20 @@ static void max9286_cleanup_dt(struct max9286_priv *priv)
 	for_each_source(priv, source) {
 		fwnode_handle_put(source->fwnode);
 		source->fwnode = NULL;
+		if (source->dev)
+		{
+			device_unregister(source->dev);
+			source->dev = NULL;
+		}
 	}
 }
 
+static void max9286_source_dev_release(struct device *dev)
+{
+	of_node_put(dev->of_node);
+	kfree(dev);
+}
+
 static int max9286_parse_dt(struct max9286_priv *priv)
 {
 	struct device *dev = &priv->client->dev;
@@ -1138,6 +1180,8 @@ static int max9286_parse_dt(struct max9286_priv *priv)
 	unsigned int i2c_mux_mask = 0;
 	u32 reverse_channel_microvolt;
 
+	int ret;
+
 	/* Balance the of_node_put() performed by of_find_node_by_name(). */
 	of_node_get(dev->of_node);
 	i2c_mux = of_find_node_by_name(dev->of_node, "i2c-mux");
@@ -1184,7 +1228,6 @@ static int max9286_parse_dt(struct max9286_priv *priv)
 			struct v4l2_fwnode_endpoint vep = {
 				.bus_type = V4L2_MBUS_CSI2_DPHY
 			};
-			int ret;
 
 			ret = v4l2_fwnode_endpoint_parse(
 					of_fwnode_handle(node), &vep);
@@ -1222,6 +1265,48 @@ static int max9286_parse_dt(struct max9286_priv *priv)
 			continue;
 		}
 
+		/*
+		 * Register a device for the port, to support usage of the regulator
+		 * API.
+		 */
+		source->dev = kzalloc(sizeof(*source->dev), GFP_KERNEL);
+		if (!source->dev)
+		{
+			of_node_put(node);
+			return -ENOMEM;
+		}
+
+		source->dev->parent = dev;
+		source->dev->of_node = of_get_parent(node);
+		source->dev->release = &max9286_source_dev_release;
+		dev_set_name(source->dev, "%s-port%u", dev_name(dev),
+			ep.port);
+
+		ret = device_register(source->dev);
+		if (ret < 0) {
+			dev_err(dev,
+				"Failed to register device for port %u\n", ep.port);
+			put_device(source->dev);
+			source->dev = NULL;
+			of_node_put(node);
+			return ret;
+		}
+
+		/* Retrieve the port-poc supply, if no global regulator */
+		if (!priv->regulator) {
+			source->regulator = devm_regulator_get_exclusive(source->dev, "port-poc");
+			if (IS_ERR(source->regulator)) {
+				dev_info(source->dev, "ERROR PoC regulator\n");
+				if (PTR_ERR(source->regulator) != -EPROBE_DEFER)
+					dev_err(source->dev,
+						"Unable to get PoC regulator (%ld)\n",
+						PTR_ERR(source->regulator));
+				ret = PTR_ERR(source->regulator);
+				of_node_put(node);
+				return ret;
+			}
+		}
+
 		priv->source_mask |= BIT(ep.port);
 		priv->nsources++;
 	}
@@ -1249,6 +1334,7 @@ static int max9286_parse_dt(struct max9286_priv *priv)
 static int max9286_probe(struct i2c_client *client)
 {
 	struct max9286_priv *priv;
+
 	int ret;
 
 	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
@@ -1290,19 +1376,27 @@ static int max9286_probe(struct i2c_client *client)
 	if (ret)
 		goto err_powerdown;
 
-	priv->regulator = devm_regulator_get(&client->dev, "poc");
+	priv->regulator = devm_regulator_get_exclusive(&client->dev, "poc");
 	if (IS_ERR(priv->regulator)) {
-		if (PTR_ERR(priv->regulator) != -EPROBE_DEFER)
-			dev_err(&client->dev,
-				"Unable to get PoC regulator (%ld)\n",
-				PTR_ERR(priv->regulator));
-		ret = PTR_ERR(priv->regulator);
-		goto err_powerdown;
+		if (PTR_ERR(priv->regulator) == -ENODEV)
+		{
+			dev_dbg(&client->dev,
+				"No Global PoC regulator, looking for port POC regulators\n");
+			priv->regulator = NULL;
+		}
+		else {
+			if (PTR_ERR(priv->regulator) != -EPROBE_DEFER)
+				dev_err(&client->dev,
+					"Unable to get PoC regulator (%ld)\n",
+					PTR_ERR(priv->regulator));
+			ret = PTR_ERR(priv->regulator);
+			goto err_powerdown;
+		}
 	}
 
 	ret = max9286_parse_dt(priv);
 	if (ret)
-		goto err_powerdown;
+		goto err_cleanup_dt;
 
 	ret = max9286_init(&client->dev);
 	if (ret < 0)
@@ -1320,13 +1414,21 @@ static int max9286_probe(struct i2c_client *client)
 
 static int max9286_remove(struct i2c_client *client)
 {
+	struct max9286_source *source;
 	struct max9286_priv *priv = i2c_get_clientdata(client);
 
 	i2c_mux_del_adapters(priv->mux);
 
 	max9286_v4l2_unregister(priv);
 
-	regulator_disable(priv->regulator);
+	if (priv->regulator)
+	{
+		regulator_disable(priv->regulator);
+	} else {
+		for_each_source(priv, source) {
+			regulator_disable(source->regulator);
+		}
+	}
 
 	gpiod_set_value_cansleep(priv->gpiod_pwdn, 0);
 
-- 
2.20.1

