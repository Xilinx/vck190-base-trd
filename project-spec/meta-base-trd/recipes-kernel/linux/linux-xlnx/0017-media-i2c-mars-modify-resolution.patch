From 380cc47d7aba4c6507968ee84d4c82dd62bca2f9 Mon Sep 17 00:00:00 2001
From: Thomas Nizan <tnizan@witekio.com>
Date: Tue, 6 Jul 2021 12:54:14 +0000
Subject: [PATCH 2/3] media: i2c: mars: modify resolution

---
 drivers/media/i2c/mars.c | 164 ++++++++++++++++++++++++++++++++-------
 1 file changed, 138 insertions(+), 26 deletions(-)

diff --git a/drivers/media/i2c/mars.c b/drivers/media/i2c/mars.c
index 891df39d5b8c..7194fb1341fe 100644
--- a/drivers/media/i2c/mars.c
+++ b/drivers/media/i2c/mars.c
@@ -19,6 +19,7 @@
 #include <linux/i2c.h>
 #include <linux/regmap.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include <linux/slab.h>
 #include <linux/videodev2.h>
 
@@ -28,22 +29,9 @@
 
 #include "max9271.h"
 
-#define AR0231_WIDTH			1920
-#define AR0231_HEIGHT			1080
-
-/*
- * As the drivers supports a single MEDIA_BUS_FMT_UYVY8_2X8 format we
- * can harcode the pixel rate.
- *
- * PCLK is fed through the system clock, programmed @88MHz.
- * MEDIA_BUS_FMT_UYVY8_2X8 format = 2 samples per pixel.
- *
- * Pixelrate = PCLK / 2
- * FPS = (OV10635_VTS * OV10635_HTS) / PixelRate
- *     = 29,9998
- */
 #define AR0231_PIXEL_RATE		(75000000)
 
+#define MARS_MODE_REG_TABLE_SIZE 15
 
 /* There's no standard V4L2_CID_GREEN_BALANCE defined in the
  * linux kernel. Let's borrow V4L2_CID_CHROMA_GAIN on green
@@ -61,6 +49,67 @@ struct mars_device {
 	struct v4l2_ctrl_handler	ctrls;
 	u32				addrs[2];
     struct regmap *sensor_regmap;
+    struct v4l2_mbus_framefmt fmt;
+
+    /* Protects fmt structure */
+    struct mutex mutex;
+};
+
+static const struct ar0231_reg mode_1280x720[] = {
+    { 0x301A, 0x10D8 }, // RESET_REGISTER
+    { 0x3004, 0x0140 }, // X_ADDR_START = 320
+    { 0x3008, 0x063F }, // X_ADDR_END = 1599 ... 1599-320 = 1279
+    { 0x3002, 0x00F0 }, // Y_ADDR_START = 240
+    { 0x3006, 0x03BF }, // Y_ADDR_END = 959 ... 959-240 =719
+    { 0x3032, 0x0000 }, // SCALING_MODE
+    { 0x3400, 0x0010 }, // RESERVED_MFR_3400
+    { 0x3402, 0x0F10 }, // X_OUTPUT_CONTROL
+    { 0x3402, 0x0A10 }, // X_OUTPUT_CONTROL
+    { 0x3404, 0x0880 }, // Y_OUTPUT_CONTROL
+    { 0x3404, 0x05B0 }, // Y_OUTPUT_CONTROL
+    { 0x300C, 0x05DC },  // LINE_LENGTH_PCK_ = 1500 (1280+220 or 1280+17%)
+    { 0x300A, 0x0335 },  // FRAME_LENGTH_LINES_ = 821
+    { 0x3042, 0x0000 },  // EXTRA_DELAY = 0
+                        // TOTAL CYCLES = 1500*821 + 0
+                        // = 1,315,000
+    { 0x301A, 0x19DC }, // RESET_REGISTER
+};
+
+static const struct ar0231_reg mode_1920x1080[] = {
+    { 0x301A, 0x10D8 }, // RESET_REGISTER
+    { 0x3004, 0x0000 }, // X_ADDR_START = 0
+    { 0x3008, 0x077F }, // X_ADDR_END = 1919
+    { 0x3002, 0x003C }, // Y_ADDR_START = 60
+    { 0x3006, 0x0473 }, // Y_ADDR_END = 1139 ... 1139-60 // =1079
+    { 0x3032, 0x0000 }, // SCALING_MODE
+    { 0x3400, 0x0010 }, // RESERVED_MFR_3400
+    { 0x3402, 0x0F10 }, // X_OUTPUT_CONTROL
+    { 0x3402, 0x0F10 }, // X_OUTPUT_CONTROL
+    { 0x3404, 0x0880 }, // Y_OUTPUT_CONTROL
+    { 0x3404, 0x0880 }, // Y_OUTPUT_CONTROL
+    { 0x300C, 0x080E },  // LINE_LENGTH_PCK_ = 2062
+    { 0x300A, 0x0484 },  // FRAME_LENGTH_LINES_ = 1156
+    { 0x3042, 0x0000 },  // EXTRA_DELAY = 0
+                        // TOTAL CYCLES = 2062*1156 + 0
+                        // = 2,383,672
+    { 0x301A, 0x19DC }, // RESET_REGISTER
+};
+
+static const struct mars_mode {
+    u32 width;
+    u32 height;
+    const struct ar0231_reg *reg_table;
+} mars_modes[] = {
+    {
+        .width = 1920,
+        .height = 1080,
+        .reg_table = mode_1920x1080,
+    },
+    {
+        .width = 1280,
+        .height = 720,
+        .reg_table = mode_1280x720,
+    },
 };
 
 static inline struct mars_device *sd_to_mars(struct v4l2_subdev *sd)
@@ -329,22 +378,68 @@ static int mars_enum_mbus_code(struct v4l2_subdev *sd,
 	return 0;
 }
 
+static struct v4l2_mbus_framefmt *
+mars_get_pad_format(struct mars_device *dev,
+               struct v4l2_subdev_pad_config *cfg,
+               unsigned int pad, u32 which)
+{
+    switch (which) {
+    case V4L2_SUBDEV_FORMAT_TRY:
+        return v4l2_subdev_get_try_format(&dev->sd, cfg, pad);
+    case V4L2_SUBDEV_FORMAT_ACTIVE:
+        return &dev->fmt;
+    default:
+        return NULL;
+    }
+}
+
 static int mars_get_fmt(struct v4l2_subdev *sd,
 			   struct v4l2_subdev_pad_config *cfg,
 			   struct v4l2_subdev_format *format)
 {
-	struct v4l2_mbus_framefmt *mf = &format->format;
+    struct mars_device *dev = sd_to_mars(sd);
 
-	if (format->pad)
-		return -EINVAL;
+    if (format->pad)
+        return -EINVAL;
 
-	mf->width		= AR0231_WIDTH;
-	mf->height		= AR0231_HEIGHT;
-	mf->code		= MEDIA_BUS_FMT_SGRBG8_1X8;
-	mf->colorspace		= V4L2_COLORSPACE_SRGB;
-	mf->field		= V4L2_FIELD_NONE;
+    mutex_lock(&dev->mutex);
+    format->format = *mars_get_pad_format(dev, cfg, format->pad,
+                          format->which);
+    mutex_unlock(&dev->mutex);
 
-	return 0;
+    return 0;
+}
+
+static int mars_set_fmt(struct v4l2_subdev *sd,
+               struct v4l2_subdev_pad_config *cfg,
+               struct v4l2_subdev_format *format)
+{
+    struct mars_device *dev = sd_to_mars(sd);
+    struct v4l2_mbus_framefmt *cfg_fmt;
+
+    const struct mars_mode *mode;
+
+    if (format->pad)
+        return -EINVAL;
+
+    cfg_fmt = mars_get_pad_format(dev, cfg, format->pad, format->which);
+    if (!cfg_fmt)
+        return -EINVAL;
+
+    mode = v4l2_find_nearest_size(mars_modes,
+                      ARRAY_SIZE(mars_modes), width, height,
+                      format->format.width,
+                      format->format.height);
+
+    sensor_set_regs(dev, mode->reg_table, MARS_MODE_REG_TABLE_SIZE);
+
+    mutex_lock(&dev->mutex);
+    *cfg_fmt = format->format;
+    cfg_fmt->width = mode->width;
+    cfg_fmt->height = mode->height;
+    mutex_unlock(&dev->mutex);
+
+    return 0;
 }
 
 static struct v4l2_subdev_video_ops mars_video_ops = {
@@ -354,7 +449,7 @@ static struct v4l2_subdev_video_ops mars_video_ops = {
 static const struct v4l2_subdev_pad_ops mars_subdev_pad_ops = {
 	.enum_mbus_code = mars_enum_mbus_code,
 	.get_fmt	= mars_get_fmt,
-	.set_fmt	= mars_get_fmt,
+	.set_fmt	= mars_set_fmt,
 };
 
 static struct v4l2_subdev_ops mars_subdev_ops = {
@@ -469,6 +564,18 @@ static struct v4l2_ctrl_config ar0231_sd_ctrls[] = {
     },
 };
 
+static void mars_init_format(struct v4l2_mbus_framefmt *fmt)
+{
+    fmt->width          = mars_modes[0].width;
+    fmt->height         = mars_modes[0].height;
+    fmt->code           = MEDIA_BUS_FMT_SGRBG8_1X8;
+    fmt->colorspace     = V4L2_COLORSPACE_SRGB;
+    fmt->field          = V4L2_FIELD_NONE;
+    fmt->ycbcr_enc      = V4L2_YCBCR_ENC_DEFAULT;
+    fmt->quantization   = V4L2_QUANTIZATION_DEFAULT;
+    fmt->xfer_func      = V4L2_XFER_FUNC_DEFAULT;
+}
+
 static int mars_initialize(struct mars_device *dev)
 {
 	unsigned int retry = 3;
@@ -600,6 +707,8 @@ static int mars_probe(struct i2c_client *client)
 		return -ENOMEM;
 	dev->dev = &client->dev;
 
+    mutex_init(&dev->mutex);
+
 	dev->serializer = devm_kzalloc(&client->dev, sizeof(*dev->serializer),
 				       GFP_KERNEL);
 	if (!dev->serializer)
@@ -629,8 +738,11 @@ static int mars_probe(struct i2c_client *client)
         goto error;
     }
 
+
     dev_info(dev->dev, "Mars module initialized\n");
 
+    mars_init_format(&dev->fmt);    
+
 	/* Initialize and register the subdevice. */
 	v4l2_i2c_subdev_init(&dev->sd, client, &mars_subdev_ops);
 	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
@@ -668,8 +780,6 @@ static int mars_probe(struct i2c_client *client)
 	if (ret)
 		goto error_free_ctrls;
 
-
-
 	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
 	dev->sd.entity.flags |= MEDIA_ENT_F_CAM_SENSOR;
 	ret = media_entity_pads_init(&dev->sd.entity, 1, &dev->pad);
@@ -718,6 +828,8 @@ static int mars_remove(struct i2c_client *client)
 	media_entity_cleanup(&dev->sd.entity);
 	i2c_unregister_device(dev->sensor);
 
+    mutex_destroy(&dev->mutex);
+
 	return 0;
 }
 
-- 
2.20.1

