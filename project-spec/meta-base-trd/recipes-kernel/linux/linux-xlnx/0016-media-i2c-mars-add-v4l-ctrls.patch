From 745d75b5f5e0911db9cba6df5a15f9d2e9f32177 Mon Sep 17 00:00:00 2001
From: Thomas Nizan <tnizan@witekio.com>
Date: Tue, 22 Jun 2021 16:55:37 +0000
Subject: [PATCH 1/3] media: i2c: mars: add v4l ctrls

---
 drivers/media/i2c/mars.c | 342 ++++++++++++++++++++++++++++++++++++++-
 1 file changed, 338 insertions(+), 4 deletions(-)

diff --git a/drivers/media/i2c/mars.c b/drivers/media/i2c/mars.c
index 7fcc021d82a3..891df39d5b8c 100644
--- a/drivers/media/i2c/mars.c
+++ b/drivers/media/i2c/mars.c
@@ -4,6 +4,7 @@
  *
  */
 
+#define DEBUG
 /*
  * The camera is made of an ON Semiconductor AR0231 sensor connected to a Maxim
  * MAX96705 GMSL serializer.
@@ -44,6 +45,12 @@
 #define AR0231_PIXEL_RATE		(75000000)
 
 
+/* There's no standard V4L2_CID_GREEN_BALANCE defined in the
+ * linux kernel. Let's borrow V4L2_CID_CHROMA_GAIN on green
+ * balance adjustment
+ */
+#define V4L2_CID_GREEN_BALANCE V4L2_CID_CHROMA_GAIN
+
 
 struct mars_device {
 	struct device			*dev;
@@ -108,6 +115,199 @@ static int sensor_set_regs(struct mars_device *dev,
  return 0;
 }
 
+/* -----------------------------------------------------------------------
+ * Register Configuration
+ */
+
+#define AR0231_COARSE_INTEGRATION_TIME_ 0x3012
+#define AR0231_BLUE_GAIN 0x3058
+#define AR0231_GREEN1_GAIN 0x3056
+#define AR0231_GREEN2_GAIN 0x305C
+#define AR0231_RED_GAIN 0x305A
+#define AR0231_ANALOG_GAIN 0x3366
+#define AR0231_DIGITAL_GAIN 0x3308
+#define AR0231_READ_MODE 0x3040
+#define AR0231_READ_MODE_HORIZ_MIRROR   BIT(14)
+#define AR0231_READ_MODE_VERT_FLIP   BIT(15)
+#define AR0231_TEST_PATTERN_MODE_ 0x3070
+
+static const struct ar0231_reg ar0231_test_pattern_none[] = {
+    { 0x3022, 0x0001 }, // GROUPED_PARAMETER_HOLD_
+    { 0x3070, 0x0000 }, // Test Pattern = normal
+    { 0x3072, 0x0000 }, // Red    = 0x0000
+    { 0x3074, 0x0000 }, // Green1 = 0x0000
+    { 0x3076, 0x0000 }, // Blue   = 0x0000
+    { 0x3078, 0x0000 }, // Green2 = 0x0000
+    { 0x307A, 0x0000 }, // ?
+    { 0x3022, 0x0000 }, // GROUPED_PARAMETER_HOLD_
+};
+
+static const struct ar0231_reg ar0231_test_pattern_solid_red[] = {
+    { 0x3022, 0x0001 }, // GROUPED_PARAMETER_HOLD_
+    { 0x3070, 0x0001 }, // Test Pattern = solid color
+    { 0x3072, 0x0FFF }, // Red    = 0x0FFF
+    { 0x3074, 0x0000 }, // Green1 = 0x0000
+    { 0x3076, 0x0000 }, // Blue   = 0x0000
+    { 0x3078, 0x0000 }, // Green2 = 0x0000
+    { 0x307A, 0x0000 }, // ?
+    { 0x3022, 0x0000 }, // GROUPED_PARAMETER_HOLD_
+};
+
+static const struct ar0231_reg ar0231_test_pattern_solid_green[] = {
+    { 0x3022, 0x0001 }, // GROUPED_PARAMETER_HOLD_
+    { 0x3070, 0x0001 }, // Test Pattern = solid color
+    { 0x3072, 0x0000 }, // Red    = 0x0000
+    { 0x3074, 0x0FFF }, // Green1 = 0x0FFF
+    { 0x3076, 0x0000 }, // Blue   = 0x0000
+    { 0x3078, 0x0FFF }, // Green2 = 0x0FFF
+    { 0x307A, 0x0000 }, // ?
+    { 0x3022, 0x0000 }, // GROUPED_PARAMETER_HOLD_
+};
+
+static const struct ar0231_reg ar0231_test_pattern_solid_blue[] = {
+    { 0x3022, 0x0001 }, // GROUPED_PARAMETER_HOLD_
+    { 0x3070, 0x0001 }, // Test Pattern = solid color
+    { 0x3072, 0x0000 }, // Red    = 0x0000
+    { 0x3074, 0x0000 }, // Green1 = 0x0000
+    { 0x3076, 0x0FFF }, // Blue   = 0x0FFF
+    { 0x3078, 0x0000 }, // Green2 = 0x0000
+    { 0x307A, 0x0000 }, // ?
+    { 0x3022, 0x0000 }, // GROUPED_PARAMETER_HOLD_
+};
+
+static const struct ar0231_reg ar0231_test_pattern_cbars_full[] = {
+    { 0x3022, 0x0001 }, // GROUPED_PARAMETER_HOLD_
+    { 0x3070, 0x0002 }, // Test Pattern = solid color bars
+    { 0x3072, 0x0000 }, // Red    = 0x0000
+    { 0x3074, 0x0000 }, // Green1 = 0x0000
+    { 0x3076, 0x0000 }, // Blue   = 0x0000
+    { 0x3078, 0x0000 }, // Green2 = 0x0000
+    { 0x307A, 0x0000 }, // ?
+    { 0x3022, 0x0000 }, // GROUPED_PARAMETER_HOLD_
+};
+static const struct ar0231_reg ar0231_test_pattern_cbars_f2g[] = {
+    { 0x3022, 0x0001 }, // GROUPED_PARAMETER_HOLD_
+    { 0x3070, 0x0003 }, // Test Pattern = fade to grey color bars
+    { 0x3072, 0x0000 }, // Red    = 0x0000
+    { 0x3074, 0x0000 }, // Green1 = 0x0000
+    { 0x3076, 0x0000 }, // Blue   = 0x0000
+    { 0x3078, 0x0000 }, // Green2 = 0x0000
+    { 0x307A, 0x0000 }, // ?
+    { 0x3022, 0x0000 }, // GROUPED_PARAMETER_HOLD_
+};
+
+static int ar0231_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+    unsigned int val;
+    int ret = 0;
+
+    struct mars_device *dev =
+        container_of(ctrl->handler, struct mars_device, ctrls);
+
+    dev_dbg(dev->dev, "s_ctrl: %s, value: %d.\n",
+        ctrl->name, ctrl->val);
+
+    switch (ctrl->id) {
+    case V4L2_CID_EXPOSURE:
+        dev_dbg(dev->dev, "set V4L2_CID_EXPOSURE\n");
+        ret = sensor_write(dev, AR0231_COARSE_INTEGRATION_TIME_, ctrl->val);
+        break;
+    case V4L2_CID_ANALOGUE_GAIN:
+        val = ((ctrl->val & 0x0f) << 12)  | ((ctrl->val & 0x0f) << 8) |
+            ((ctrl->val & 0x0f) << 4) | (ctrl->val & 0x0f);
+        dev_dbg(dev->dev, "set V4L2_CID_ANALOGUE_GAIN 0x%04X\n", val);
+        ret = sensor_write(dev, AR0231_ANALOG_GAIN, val);
+        break;
+    case V4L2_CID_GAIN:
+        dev_dbg(dev->dev, "set V4L2_CID_GAIN\n");
+        ret = sensor_write(dev, AR0231_DIGITAL_GAIN, ctrl->val);
+        break;
+    case V4L2_CID_HFLIP:
+        dev_dbg(dev->dev, "set V4L2_CID_HFLIP\n");
+        ret = sensor_read(dev, AR0231_READ_MODE, &val);
+
+        dev_dbg(dev->dev, "old val 0x%04X\n", val);
+
+        if (ret < 0)
+            break;
+        if (ctrl->val)
+            val |= AR0231_READ_MODE_HORIZ_MIRROR;
+        else
+            val &= ~AR0231_READ_MODE_HORIZ_MIRROR;
+
+        dev_dbg(dev->dev, "new val 0x%04X\n", val);
+        ret = sensor_write(dev, AR0231_READ_MODE, val);
+        break;
+    case V4L2_CID_VFLIP:
+        dev_dbg(dev->dev, "set V4L2_CID_VFLIP\n");
+        ret = sensor_read(dev, AR0231_READ_MODE, &val);
+
+        dev_dbg(dev->dev, "old val 0x%04X\n", val);
+
+        if (ret < 0)
+            break;
+        if (ctrl->val)
+            val |= AR0231_READ_MODE_VERT_FLIP;
+        else
+            val &= ~AR0231_READ_MODE_VERT_FLIP;
+
+        dev_dbg(dev->dev, "new val 0x%04X\n", val);
+        ret = sensor_write(dev, AR0231_READ_MODE, val);
+        break;
+    case V4L2_CID_RED_BALANCE:
+        dev_dbg(dev->dev, "set V4L2_CID_RED_BALANCE\n");
+        ret = sensor_write(dev, AR0231_RED_GAIN, ctrl->val);
+        break;
+    case V4L2_CID_BLUE_BALANCE:
+        dev_dbg(dev->dev, "set V4L2_CID_BLUE_BALANCE\n");
+        ret = sensor_write(dev, AR0231_BLUE_GAIN, ctrl->val);
+        break;
+    case V4L2_CID_GREEN_BALANCE:
+        dev_dbg(dev->dev, "set V4L2_CID_GREEN_BALANCE\n");
+        ret = sensor_write(dev, AR0231_GREEN1_GAIN, ctrl->val);
+        if (ret < 0)
+            break;
+
+        ret = sensor_write(dev, AR0231_GREEN2_GAIN, ctrl->val);
+        break;
+    case V4L2_CID_TEST_PATTERN:
+        switch (ctrl->val) {
+        case 0:
+            ret = sensor_set_regs(dev, ar0231_test_pattern_none,
+                    ARRAY_SIZE(ar0231_test_pattern_none));
+            break;
+        case 1:
+            ret = sensor_set_regs(dev, ar0231_test_pattern_solid_red,
+                    ARRAY_SIZE(ar0231_test_pattern_solid_red));
+            break;
+        case 2:
+            ret = sensor_set_regs(dev, ar0231_test_pattern_solid_green,
+                    ARRAY_SIZE(ar0231_test_pattern_solid_green));
+            break;
+        case 3:
+            ret = sensor_set_regs(dev, ar0231_test_pattern_solid_blue,
+                    ARRAY_SIZE(ar0231_test_pattern_solid_blue));
+            break;
+        case 4:
+            ret = sensor_set_regs(dev, ar0231_test_pattern_cbars_full,
+                    ARRAY_SIZE(ar0231_test_pattern_cbars_full));
+            break;
+        case 5:
+            ret = sensor_set_regs(dev, ar0231_test_pattern_cbars_f2g,
+                    ARRAY_SIZE(ar0231_test_pattern_cbars_f2g));
+            break;
+        default:
+            ret = -EINVAL;
+            break;
+        }
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    return ret;
+}
+
 static int mars_s_stream(struct v4l2_subdev *sd, int enable)
 {
 	struct mars_device *dev = sd_to_mars(sd);
@@ -162,6 +362,113 @@ static struct v4l2_subdev_ops mars_subdev_ops = {
 	.pad		= &mars_subdev_pad_ops,
 };
 
+static const struct v4l2_ctrl_ops ar0231_ctrl_ops = {
+    .s_ctrl = ar0231_s_ctrl,
+};
+
+static const char * const test_pattern_menu[] = {
+    "Disabled",
+    "Solid Red",
+    "Solid Green",
+    "Solid Blue",
+    "Color Bars (full)",
+    "Color Bars (f2grey)",
+};
+
+const s64 test_pattern_menu_index[] = {0, 1, 2, 3, 4, 5};
+
+static struct v4l2_ctrl_config ar0231_sd_ctrls[] = {
+    {
+        .id = V4L2_CID_PIXEL_RATE,
+        .min    = AR0231_PIXEL_RATE,
+        .max    = AR0231_PIXEL_RATE,
+        .step   = 1,
+        .def    = AR0231_PIXEL_RATE,
+    }, {
+        .ops    = &ar0231_ctrl_ops,
+        .id = V4L2_CID_EXPOSURE,
+        .name   = "AR0231 Exposure",
+        .type   = V4L2_CTRL_TYPE_INTEGER,
+        .min    = 0x10,
+        .max    = 0x53b,
+        .step   = 1,
+        .def    = 0x0335,
+    }, {
+        .ops    = &ar0231_ctrl_ops,
+        .id = V4L2_CID_ANALOGUE_GAIN,
+        .name   = "AR0231 Analog Gain",
+        .type   = V4L2_CTRL_TYPE_INTEGER,
+        .min    = 0,
+        .max    = 0xe,
+        .step   = 1,
+        .def    = 7,
+    }, {
+        .ops    = &ar0231_ctrl_ops,
+        .id = V4L2_CID_GAIN,
+        .name   = "AR0231 Digital Gain",
+        .type   = V4L2_CTRL_TYPE_INTEGER,
+        .min    = 0,
+        .max    = 0x7ff,
+        .step   = 1,
+        .def    = 0x200,
+    }, {
+        .ops    = &ar0231_ctrl_ops,
+        .id = V4L2_CID_RED_BALANCE,
+        .name   = "AR0231 Red Balance",
+        .type   = V4L2_CTRL_TYPE_INTEGER,
+        .min    = 0,
+        .max    = 0x7ff,
+        .step   = 1,
+        .def    = 0x80,
+    }, {
+        .ops    = &ar0231_ctrl_ops,
+        .id = V4L2_CID_BLUE_BALANCE,
+        .name   = "AR0231 Blue Balance",
+        .type   = V4L2_CTRL_TYPE_INTEGER,
+        .min    = 0,
+        .max    = 0x7ff,
+        .step   = 1,
+        .def    = 0x26b,
+    }, {
+        .ops    = &ar0231_ctrl_ops,
+        .id = V4L2_CID_GREEN_BALANCE,
+        .name   = "AR0231 Green Balance",
+        .type   = V4L2_CTRL_TYPE_INTEGER,
+        .min    = 0,
+        .max    = 0x7ff,
+        .step   = 1,
+        .def    = 0x91,
+    }, {
+        .ops    = &ar0231_ctrl_ops,
+        .id = V4L2_CID_HFLIP,
+        .name   = "AR0231 Horizontal Flip",
+        .type   = V4L2_CTRL_TYPE_BOOLEAN,
+        .min    = 0,
+        .max    = 1,
+        .step   = 1,
+        .def    = 0,
+    }, {
+        .ops    = &ar0231_ctrl_ops,
+        .id = V4L2_CID_VFLIP,
+        .name   = "AR0231 Vertical Flip",
+        .type   = V4L2_CTRL_TYPE_BOOLEAN,
+        .min    = 0,
+        .max    = 1,
+        .step   = 1,
+        .def    = 0,
+    }, {
+        .ops = &ar0231_ctrl_ops,
+        .id = V4L2_CID_TEST_PATTERN,
+        .name = "AR0231 Test Pattern",
+        .type = V4L2_CTRL_TYPE_MENU,
+        .min = 0,
+        .max = ARRAY_SIZE(test_pattern_menu) - 1,
+        .menu_skip_mask = 0,
+        .def = 0,
+        .qmenu = test_pattern_menu,
+    },
+};
+
 static int mars_initialize(struct mars_device *dev)
 {
 	unsigned int retry = 3;
@@ -284,6 +591,8 @@ static int mars_probe(struct i2c_client *client)
 {
 	struct mars_device *dev;
 	struct fwnode_handle *ep;
+    int num_ctrls;
+    int i;
 	int ret;
 
 	dev = devm_kzalloc(&client->dev, sizeof(*dev), GFP_KERNEL);
@@ -326,16 +635,41 @@ static int mars_probe(struct i2c_client *client)
 	v4l2_i2c_subdev_init(&dev->sd, client, &mars_subdev_ops);
 	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
 
-	v4l2_ctrl_handler_init(&dev->ctrls, 1);
-	v4l2_ctrl_new_std(&dev->ctrls, NULL, V4L2_CID_PIXEL_RATE,
-			  AR0231_PIXEL_RATE, AR0231_PIXEL_RATE, 1,
-			  AR0231_PIXEL_RATE);
+    num_ctrls = ARRAY_SIZE(ar0231_sd_ctrls);
+    dev_dbg(dev->dev, "# of ctrls = %d\n", num_ctrls);
+
+    v4l2_ctrl_handler_init(&dev->ctrls, num_ctrls + 1);
+
+    v4l2_ctrl_new_std(&dev->ctrls, NULL, V4L2_CID_PIXEL_RATE,
+              AR0231_PIXEL_RATE, AR0231_PIXEL_RATE, 1,
+              AR0231_PIXEL_RATE);
+
+    for (i = 0; i < num_ctrls; i++) {
+        struct v4l2_ctrl *ctrl;
+
+        dev_dbg(dev->dev, "%d ctrl %s = 0x%x\n", i, ar0231_sd_ctrls[i].name,
+            ar0231_sd_ctrls[i].id);
+
+        ctrl = v4l2_ctrl_new_custom(&dev->ctrls,
+                        &ar0231_sd_ctrls[i], NULL);
+        if (!ctrl) {
+            dev_err(dev->dev, "Failed for %s ctrl\n",
+                ar0231_sd_ctrls[i].name);
+            goto error_free_ctrls;
+        }
+    }
+
+    dev_dbg(dev->dev, "# v4l2 ctrls registered = %d\n", i - 1);
+
+
 	dev->sd.ctrl_handler = &dev->ctrls;
 
 	ret = dev->ctrls.error;
 	if (ret)
 		goto error_free_ctrls;
 
+
+
 	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
 	dev->sd.entity.flags |= MEDIA_ENT_F_CAM_SENSOR;
 	ret = media_entity_pads_init(&dev->sd.entity, 1, &dev->pad);
-- 
2.20.1

